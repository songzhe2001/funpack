#include "tcpecho.h"

#include "board.h"
#include "fsl_p3t1755.h"
#include "lwip/netif.h"
#include "lwip/ip.h"
#include "lwip/tcp.h"
#include "lwip/init.h"
#include "netif/etharp.h"
#include "lwip/udp.h"
#include "lwip/pbuf.h"
#include <stdio.h>
#include <string.h>

extern double temperature;
extern int static touch_state;


static err_t tcpecho_recv(void *arg,
		struct tcp_pcb *tpcb,
		struct pbuf *p,
		err_t err)
{
	struct pbuf *q;
	uint32_t data_len=0;
	int dac_value=0;
	char receive_buf[5];
	char output_buf[10];


	if (p != NULL)
	{
		/* 更新窗口*/
		tcp_recved(tpcb, p->tot_len);
		for(q=p;q!=NULL;q=q->next)
		{
			memcpy(receive_buf+data_len,q->payload,q->tot_len);
			data_len+=q->tot_len;
		}
		if(receive_buf[0]=='r')
			GPIO_PortToggle(BOARD_LED_RED_GPIO, 1u << BOARD_LED_RED_GPIO_PIN);
		if(receive_buf[0]=='g')
			GPIO_PortToggle(BOARD_LED_GREEN_GPIO, 1u << BOARD_LED_GREEN_GPIO_PIN);
		if(receive_buf[0]=='b')
			GPIO_PortToggle(BOARD_LED_BLUE_GPIO, 1u << BOARD_LED_BLUE_GPIO_PIN);

		PRINTF("%d\n",receive_buf[0]);
		if(receive_buf[0]=='t')
		{
			PRINTF("%f\n",temperature);
			sprintf(output_buf,"%f\n",temperature);
			tcp_write(tpcb, output_buf, sizeof(output_buf), 1);
		}
		if(receive_buf[0]=='s')
		{
			PRINTF("%d\n",touch_state);
			sprintf(output_buf,"%d\n",touch_state);
			tcp_write(tpcb, output_buf, sizeof(output_buf), 1);
		}
		/* 返回接收到的数据*/
		tcp_write(tpcb, p->payload, p->tot_len, 1);

		memset(p->payload, 0 , p->tot_len);

		pbuf_free(p);



	}
	else if (err == ERR_OK)
	{
		return tcp_close(tpcb);
	}
	return ERR_OK;
}

static err_t tcpecho_accept(void *arg,
		struct tcp_pcb *newpcb,
		err_t err)
{
	tcp_recv(newpcb, tcpecho_recv);
	return ERR_OK;
}

void TCP_Echo_Init(void)
{
	struct tcp_pcb *pcb = NULL;

	/* 创建一个TCP控制块  */
	pcb = tcp_new();

	/* 绑定TCP控制块 */
	tcp_bind(pcb, IP_ADDR_ANY, TCP_ECHO_PORT);


	/* 进入监听状态 */
	pcb = tcp_listen(pcb);

	/* 处理连接 */
	tcp_accept(pcb, tcpecho_accept);
}
